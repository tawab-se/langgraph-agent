<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LangGraph Agent</title>
  <link rel="stylesheet" href="/styles.css">
  <script src="https://js.puter.com/v2/"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div class="header">
    <span class="header-icon">&#129302;</span>
    <div>
      <h1>LangGraph Agent</h1>
      <p>Weaviate RAG &bull; Chart.js &bull; Gemini &bull; Pollinations.ai &bull; Puter.js</p>
    </div>
    <button class="about-btn" onclick="document.getElementById('aboutOverlay').classList.add('active')">&#9432; About</button>
  </div>

  <div class="chat-area" id="chatArea">
    <div class="welcome" id="welcome">
      <h2>What can I help you with?</h2>
      <p>Ask questions about company policies, products, API docs, or request charts.</p>
      <div class="examples">
        <button class="example-btn" onclick="askExample(this)">What is the remote work policy?</button>
        <button class="example-btn" onclick="askExample(this)">Show me a bar chart of sales</button>
        <button class="example-btn" onclick="askExample(this)">What are the ProductX pricing tiers?</button>
        <button class="example-btn" onclick="askExample(this)">What is 25 + 17?</button>
        <button class="example-btn" onclick="askExample(this)">Generate an image of a sunset over mountains</button>
      </div>
    </div>
  </div>

  <div class="input-area">
    <div id="attachmentPreview" class="image-attachment-preview" style="display:none"></div>
    <div class="input-wrapper">
      <input type="file" id="fileInput" accept=".pdf" />
      <input type="file" id="imageInput" accept="image/jpeg,image/png,image/webp" style="display:none" />
      <button class="upload-btn" id="uploadBtn" onclick="document.getElementById('fileInput').click()" title="Upload PDF">
        &#128206; PDF
      </button>
      <button class="upload-btn" id="imageBtn" onclick="document.getElementById('imageInput').click()" title="Attach image for editing">
        &#128247; IMG
      </button>
      <input
        type="text"
        id="queryInput"
        placeholder="Type your question..."
        autocomplete="off"
        autofocus
      />
      <button id="sendBtn" onclick="sendQuery()">Send</button>
    </div>
  </div>

  <script>
    // Configure marked.js for safe markdown rendering
    marked.setOptions({
      breaks: true,
      gfm: true,
    });

    const chatArea = document.getElementById('chatArea');
    const queryInput = document.getElementById('queryInput');
    const sendBtn = document.getElementById('sendBtn');
    const welcome = document.getElementById('welcome');

    // Conversation history (last 10 exchanges sent as context)
    const MAX_HISTORY = 10;
    let conversationHistory = [];

    queryInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !sendBtn.disabled) sendQuery();
    });

    function askExample(btn) {
      queryInput.value = btn.textContent;
      sendQuery();
    }

    function scrollToBottom() {
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    function addUserMessage(text) {
      if (welcome) welcome.remove();
      const div = document.createElement('div');
      div.className = 'message user';
      div.innerHTML = '<div class="bubble">' + escapeHtml(text) + '</div>';
      chatArea.appendChild(div);
      scrollToBottom();
    }

    function addLoadingMessage() {
      const div = document.createElement('div');
      div.className = 'message assistant';
      div.id = 'loading-msg';
      div.innerHTML = '<div class="bubble"><div class="loading-dots"><span></span><span></span><span></span></div></div>';
      chatArea.appendChild(div);
      scrollToBottom();
      return div;
    }

    function removeLoading() {
      const el = document.getElementById('loading-msg');
      if (el) el.remove();
    }

    const ROUTE_MAP = {
      rag: { key: 'rag', label: 'Weaviate RAG', icon: '&#128218;' },
      chart: { key: 'chart', label: 'Chart.js', icon: '&#128202;' },
      direct: { key: 'direct', label: 'Gemini LLM', icon: '&#9889;' },
      both: { key: 'both', label: 'RAG + Chart', icon: '&#9878;' },
      image: { key: 'image', label: 'Pollinations.ai', icon: '&#127912;' },
      'image-edit': { key: 'image', label: 'Puter.js Kontext', icon: '&#127912;' },
    };

    function addErrorMessage(msg) {
      const div = document.createElement('div');
      div.className = 'message assistant';
      div.innerHTML = '<div class="error-msg">' + escapeHtml(msg) + '</div>';
      chatArea.appendChild(div);
      scrollToBottom();
    }

    function buildReferencesHtml(refs) {
      let html = '<div class="references-section">'
        + '<h4><span class="section-icon">&#128218;</span> Sources from Knowledge Base</h4>';
      refs.forEach(function(ref) {
        const pages = ref.pages.join(', ');
        html += '<span class="ref-item">'
          + '<span class="ref-id">' + escapeHtml(ref.displayId) + '</span>'
          + '<span class="ref-file">' + escapeHtml(ref.fileId) + '</span>'
          + '<span class="ref-pages">Pages ' + escapeHtml(pages) + '</span>'
          + '</span>';
      });
      html += '</div>';
      return html;
    }

    function buildChartHtml(cfg, canvasId) {
      const json = JSON.stringify(cfg, null, 2);
      const jsonBlockId = canvasId + '-json';
      let html = '<div class="chart-section">'
        + '<h4><span class="section-icon">&#128202;</span> Chart</h4>'
        + '<div class="chart-meta">'
        + '<div class="chart-meta-item">Type: <span class="val">' + escapeHtml(cfg.type) + '</span></div>'
        + '<div class="chart-meta-item">Labels: <span class="val">' + cfg.data.labels.length + '</span></div>'
        + '<div class="chart-meta-item">Datasets: <span class="val">' + cfg.data.datasets.length + '</span></div>'
        + '</div>'
        + '<div class="chart-canvas-wrapper"><canvas id="' + canvasId + '"></canvas></div>'
        + '<button class="chart-json-toggle" onclick="toggleChartJson(\'' + jsonBlockId + '\', this)">&#9660; Show JSON</button>'
        + '<div id="' + jsonBlockId + '" class="chart-block" style="display:none">'
        + '<div class="chart-block-header">'
        + '<span>chart.js config</span>'
        + '<button class="copy-btn" onclick="copyToClipboard(this)">Copy JSON</button>'
        + '</div>'
        + '<pre>' + escapeHtml(json) + '</pre>'
        + '</div></div>';
      return html;
    }

    function toggleChartJson(blockId, btn) {
      var block = document.getElementById(blockId);
      if (!block) return;
      if (block.style.display === 'none') {
        block.style.display = 'block';
        btn.innerHTML = '&#9650; Hide JSON';
      } else {
        block.style.display = 'none';
        btn.innerHTML = '&#9660; Show JSON';
      }
    }

    function renderChart(canvasId, cfg) {
      var canvas = document.getElementById(canvasId);
      if (!canvas || typeof Chart === 'undefined') return;
      try {
        // Deep clone to avoid mutating original config
        var config = JSON.parse(JSON.stringify(cfg));
        // Ensure responsive behavior
        if (!config.options) config.options = {};
        config.options.responsive = true;
        config.options.maintainAspectRatio = true;
        // Dark theme defaults
        if (!config.options.plugins) config.options.plugins = {};
        if (!config.options.plugins.legend) config.options.plugins.legend = {};
        if (!config.options.plugins.legend.labels) config.options.plugins.legend.labels = {};
        config.options.plugins.legend.labels.color = '#c9d1d9';
        // Only apply axis styles for chart types that use scales (not pie/doughnut/radar/polarArea)
        var noScaleTypes = ['pie', 'doughnut', 'radar', 'polarArea'];
        if (noScaleTypes.indexOf(config.type) === -1) {
          if (!config.options.scales) config.options.scales = {};
          ['x', 'y'].forEach(function(axis) {
            if (!config.options.scales[axis]) config.options.scales[axis] = {};
            if (!config.options.scales[axis].ticks) config.options.scales[axis].ticks = {};
            config.options.scales[axis].ticks.color = '#8b949e';
            if (!config.options.scales[axis].grid) config.options.scales[axis].grid = {};
            config.options.scales[axis].grid.color = '#21262d';
          });
        }
        new Chart(canvas.getContext('2d'), config);
      } catch (err) {
        console.error('Chart render error:', err);
        canvas.parentElement.innerHTML = '<div style="color:#f85149;font-size:12px;padding:12px">Failed to render chart. JSON config is available below.</div>';
      }
    }

    function buildImageHtml(data, imgId) {
      return '<div class="image-section">'
        + '<h4>&#127912; Generated Image</h4>'
        + '<div id="' + imgId + '-loader" class="image-loading">'
        + '<div class="spinner"></div><div>Generating image... this may take 10-30 seconds</div></div>'
        + '<img id="' + imgId + '" style="display:none" alt="' + escapeHtml(data.prompt) + '" />'
        + '<div class="image-caption">' + escapeHtml(data.prompt) + ' (model: ' + escapeHtml(data.model) + ')</div>'
        + '</div>';
    }

    // Preload image with retry â€” called after buildImageHtml is inserted into DOM
    function loadGeneratedImage(url, imgId, retries) {
      if (retries === undefined) retries = 3;
      var img = new Image();
      img.onload = function() {
        var el = document.getElementById(imgId);
        var loader = document.getElementById(imgId + '-loader');
        if (el) { el.src = url; el.style.display = 'block'; }
        if (loader) loader.remove();
        scrollToBottom();
      };
      img.onerror = function() {
        if (retries > 0) {
          setTimeout(function() { loadGeneratedImage(url, imgId, retries - 1); }, 5000);
        } else {
          var loader = document.getElementById(imgId + '-loader');
          if (loader) loader.innerHTML = 'Image generation failed. <a href="' + url + '" target="_blank" style="color:#58a6ff">Open directly</a>';
        }
      };
      img.src = url;
    }

    function buildImageEditHtml(imgId) {
      return '<div class="image-section">'
        + '<h4>&#127912; Edited Image</h4>'
        + '<div id="' + imgId + '-loader" class="image-loading">'
        + '<div class="spinner"></div><div>Editing image via Puter.js... this may take 10-30 seconds</div></div>'
        + '<img id="' + imgId + '" style="display:none" />'
        + '</div>';
    }

    function runPuterImageEdit(prompt, imageUrl, imgId) {
      // Convert relative URL to absolute for Puter.js
      var absUrl = imageUrl.startsWith('http') ? imageUrl : window.location.origin + imageUrl;

      puter.ai.txt2img(prompt, {
        model: 'togetherai:black-forest-labs/flux.1-kontext-pro',
        image_url: absUrl
      }).then(function(imgEl) {
        var el = document.getElementById(imgId);
        var loader = document.getElementById(imgId + '-loader');
        if (el) {
          el.src = imgEl.src;
          el.style.display = 'block';
        }
        if (loader) loader.remove();
        scrollToBottom();
      }).catch(function(err) {
        var loader = document.getElementById(imgId + '-loader');
        if (loader) loader.innerHTML = 'Image editing failed: ' + escapeHtml(String(err.message || err));
      });
    }

    // --- Image Attachment State ---
    let pendingImageUrl = null;
    const attachmentPreview = document.getElementById('attachmentPreview');
    const imageInput = document.getElementById('imageInput');
    const imageBtn = document.getElementById('imageBtn');

    imageInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      imageInput.value = '';
      await attachImage(file);
    });

    async function attachImage(file) {
      if (!file.type.startsWith('image/')) {
        showToast('Only image files (JPEG, PNG, WebP) are supported', 'error');
        return;
      }
      if (file.size > 10 * 1024 * 1024) {
        showToast('Image too large. Maximum size is 10 MB.', 'error');
        return;
      }

      imageBtn.disabled = true;
      showToast('Uploading image...', 'uploading', 0);

      const formData = new FormData();
      formData.append('image', file);

      try {
        const res = await fetch('/api/upload/image', { method: 'POST', body: formData });
        dismissToast();
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || err.error || 'Upload failed');
        }
        const result = await res.json();
        pendingImageUrl = result.url;

        // Show preview
        attachmentPreview.style.display = 'flex';
        attachmentPreview.innerHTML = '<img src="' + escapeHtml(result.url) + '" />'
          + '<span class="attachment-name">' + escapeHtml(file.name) + ' attached</span>'
          + '<button class="remove-attachment" onclick="clearAttachment()" title="Remove">&#10005;</button>';
        queryInput.placeholder = 'Describe what to do with this image...';
        queryInput.focus();
      } catch (err) {
        dismissToast();
        showToast('Image upload failed: ' + err.message, 'error', 5000);
      } finally {
        imageBtn.disabled = false;
      }
    }

    function clearAttachment() {
      pendingImageUrl = null;
      attachmentPreview.style.display = 'none';
      attachmentPreview.innerHTML = '';
      queryInput.placeholder = 'Type your question...';
    }

    async function sendQuery() {
      const query = queryInput.value.trim();
      if (!query) return;

      const imageUrl = pendingImageUrl;
      clearAttachment();

      queryInput.value = '';
      sendBtn.disabled = true;
      queryInput.disabled = true;

      addUserMessage(imageUrl ? query + ' [image attached]' : query);
      addLoadingMessage();

      const startTime = Date.now();

      try {
        const res = await fetch('/api/chat/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query, imageUrl, history: conversationHistory }),
        });

        if (!res.ok) {
          removeLoading();
          const err = await res.json().catch(function() { return {}; });
          throw new Error(err.message || err.error || 'Request failed');
        }

        removeLoading();

        // Create streaming message container
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message assistant';
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        msgDiv.appendChild(bubble);

        // Route badge placeholder
        const badgeEl = document.createElement('div');
        badgeEl.className = 'route-badge route-direct';
        badgeEl.innerHTML = '<span class="route-dot"></span>Thinking...';
        bubble.appendChild(badgeEl);

        // Answer text element
        const answerEl = document.createElement('div');
        answerEl.className = 'answer-text';
        bubble.appendChild(answerEl);

        chatArea.appendChild(msgDiv);
        scrollToBottom();

        let answerText = '';
        let route = ROUTE_MAP.direct;
        let allData = [];

        // Parse SSE stream
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          let eventType = '';
          for (const line of lines) {
            if (line.startsWith('event: ')) {
              eventType = line.slice(7).trim();
            } else if (line.startsWith('data: ') && eventType) {
              const data = JSON.parse(line.slice(6));

              if (eventType === 'thinking') {
                badgeEl.innerHTML = '<span class="route-dot"></span>' + data;
              } else if (eventType === 'route') {
                const tool = data.tools ? data.tools[0] : 'direct';
                route = ROUTE_MAP[tool] || ROUTE_MAP.direct;
                badgeEl.className = 'route-badge route-' + route.key;
                badgeEl.innerHTML = '<span class="route-dot"></span>Answered via ' + route.label;
              } else if (eventType === 'token') {
                answerText += data;
                answerEl.innerHTML = marked.parse(answerText);
                scrollToBottom();
              } else if (eventType === 'sources') {
                answerText += '\n\nSources: ' + data;
                answerEl.innerHTML = marked.parse(answerText);
              } else if (eventType === 'references') {
                bubble.insertAdjacentHTML('beforeend', buildReferencesHtml(data));
                allData = allData.concat(data);
              } else if (eventType === 'chart') {
                var chartCanvasId = 'chart-' + Date.now();
                bubble.insertAdjacentHTML('beforeend', buildChartHtml(data, chartCanvasId));
                renderChart(chartCanvasId, data);
                allData.push({ type: 'chart', config: data });
              } else if (eventType === 'image') {
                var imgId = 'gen-img-' + Date.now();
                bubble.insertAdjacentHTML('beforeend', buildImageHtml(data, imgId));
                loadGeneratedImage(data.url, imgId);
                allData.push({ type: 'image', url: data.url, prompt: data.prompt });
              } else if (eventType === 'image-edit') {
                var editImgId = 'edit-img-' + Date.now();
                route = ROUTE_MAP['image-edit'];
                badgeEl.className = 'route-badge route-image';
                badgeEl.innerHTML = '<span class="route-dot"></span>Answered via ' + route.label;
                bubble.insertAdjacentHTML('beforeend', buildImageEditHtml(editImgId));
                runPuterImageEdit(data.prompt, data.imageUrl, editImgId);
                scrollToBottom();
              } else if (eventType === 'done') {
                if (Array.isArray(data) && data.length > 0) allData = data;
              } else if (eventType === 'error') {
                answerEl.textContent = 'Error: ' + data;
              }

              eventType = '';
            }
          }
        }

        // Add response time
        const elapsed = Date.now() - startTime;
        const timeStr = elapsed < 1000 ? elapsed + 'ms' : (elapsed / 1000).toFixed(1) + 's';
        const metaDiv = document.createElement('div');
        metaDiv.className = 'response-meta';
        metaDiv.innerHTML = '<span>' + route.icon + ' ' + route.label + '</span>'
          + '<span>&#8226;</span>'
          + '<span>' + timeStr + '</span>';
        bubble.appendChild(metaDiv);
        scrollToBottom();

        // Save to conversation history for follow-up context
        conversationHistory.push({ role: 'user', content: query });
        if (answerText.trim()) {
          conversationHistory.push({ role: 'assistant', content: answerText.trim() });
        }
        // Keep only the last MAX_HISTORY messages
        if (conversationHistory.length > MAX_HISTORY) {
          conversationHistory = conversationHistory.slice(-MAX_HISTORY);
        }

      } catch (err) {
        removeLoading();
        addErrorMessage('Error: ' + err.message);
      } finally {
        sendBtn.disabled = false;
        queryInput.disabled = false;
        queryInput.focus();
      }
    }

    function copyToClipboard(btn) {
      const pre = btn.closest('.chart-block').querySelector('pre');
      navigator.clipboard.writeText(pre.textContent).then(() => {
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy JSON'; }, 1500);
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.appendChild(document.createTextNode(text));
      return div.innerHTML;
    }

    // --- File Upload ---
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    let isUploading = false;

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) uploadFile(file);
      fileInput.value = '';
    });

    async function uploadFile(file) {
      if (isUploading) return;
      if (file.type !== 'application/pdf') {
        showToast('Only PDF files are supported', 'error');
        return;
      }
      if (file.size > 20 * 1024 * 1024) {
        showToast('File too large. Maximum size is 20 MB.', 'error');
        return;
      }

      isUploading = true;
      uploadBtn.disabled = true;
      showToast('Uploading "' + file.name + '"...', 'uploading', 0);

      const formData = new FormData();
      formData.append('pdf', file);

      try {
        const res = await fetch('/api/upload', {
          method: 'POST',
          body: formData,
        });

        dismissToast();

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || err.error || 'Upload failed');
        }

        const result = await res.json();
        showToast(result.message, 'success', 5000);
        addSystemMessage('Uploaded "' + result.filename + '" \u2014 ' + result.totalPages + ' pages, ' + result.chunksCreated + ' chunks indexed. You can now ask questions about this document.');
      } catch (err) {
        dismissToast();
        showToast('Upload failed: ' + err.message, 'error', 5000);
      } finally {
        isUploading = false;
        uploadBtn.disabled = false;
      }
    }

    function showToast(message, type, duration) {
      if (duration === undefined) duration = 4000;
      dismissToast();
      const toast = document.createElement('div');
      toast.className = 'upload-toast ' + type;
      toast.id = 'currentToast';
      toast.textContent = message;
      document.body.appendChild(toast);
      if (duration > 0) {
        setTimeout(dismissToast, duration);
      }
    }

    function dismissToast() {
      const el = document.getElementById('currentToast');
      if (el) el.remove();
    }

    function addSystemMessage(text) {
      if (welcome) welcome.remove();
      const div = document.createElement('div');
      div.className = 'message assistant';
      div.innerHTML = '<div class="bubble">'
        + '<div class="route-badge route-direct"><span class="route-dot"></span>System</div>'
        + '<div class="answer-text">' + escapeHtml(text) + '</div>'
        + '</div>';
      chatArea.appendChild(div);
      scrollToBottom();
    }

    // Drag and drop
    const dragOverlay = document.getElementById('dragOverlay');
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (e.dataTransfer.types.includes('Files')) {
        dragOverlay.classList.add('active');
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        dragOverlay.classList.remove('active');
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dragOverlay.classList.remove('active');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.type === 'application/pdf') {
          uploadFile(file);
        } else if (file.type.startsWith('image/')) {
          attachImage(file);
        } else {
          showToast('Only PDF and image files are supported', 'error');
        }
      }
    });
  </script>

  <!-- About Modal -->
  <div class="about-overlay" id="aboutOverlay" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="about-modal">
      <button class="about-close" onclick="document.getElementById('aboutOverlay').classList.remove('active')">&times;</button>

      <h2>LangGraph Agent</h2>
      <p class="about-subtitle">
        A multi-route AI agent built with LangGraph, Node.js, and Express. The agent intelligently routes each query
        to the right tool &mdash; RAG search, chart generation, direct LLM answer, text-to-image, or image editing &mdash;
        and streams the response in real time via Server-Sent Events (SSE).
      </p>

      <!-- Models Section -->
      <div class="about-section">
        <h3><span class="section-icon">&#129520;</span> Models &amp; Services</h3>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-green">Router + Direct + RAG</span>
            <span class="model-card-name">Gemini 2.5 Flash Lite</span>
          </div>
          <p>
            Google's <code>gemini-2.5-flash-lite</code> model powers three core functions:
            <strong>query routing</strong> (deciding which tool handles each query),
            <strong>direct answers</strong> (general knowledge, coding, math), and
            <strong>RAG synthesis</strong> (generating answers from retrieved document chunks).
            Free tier: 1,000 requests/day, 15 requests/minute.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-blue">Vector Database</span>
            <span class="model-card-name">Weaviate Cloud</span>
          </div>
          <p>
            Weaviate is used as the vector database for RAG (Retrieval-Augmented Generation).
            When you upload a PDF, it is parsed into text chunks and stored as vector embeddings
            in Weaviate. When a document-related query is routed to RAG, Weaviate performs a
            semantic similarity search to find the most relevant chunks.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-purple">Chart Generation</span>
            <span class="model-card-name">Chart.js via Gemini</span>
          </div>
          <p>
            When a chart or visualization is requested, Gemini generates a valid
            <code>Chart.js</code> JSON configuration (type, labels, datasets, colors).
            The chart is rendered visually inline in the chat using the Chart.js library,
            with dark-theme styling applied automatically. The raw JSON config can also
            be expanded and copied via the "Show JSON" toggle below each chart.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-pink">Text-to-Image</span>
            <span class="model-card-name">Pollinations.ai &mdash; FLUX</span>
          </div>
          <p>
            Text-to-image generation uses <code>Pollinations.ai</code> with the <code>flux</code> model.
            The server constructs a Pollinations image URL with the user's prompt, and the browser
            loads it via <code>&lt;img src&gt;</code>. The image is generated on the first GET request.
            Requires a free publishable API key (<code>pk_</code>).
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-pink">Image Editing</span>
            <span class="model-card-name">Puter.js &mdash; FLUX.1 Kontext Pro</span>
          </div>
          <p>
            Image editing (upload a photo + describe edits) uses <code>Puter.js</code> running
            client-side in the browser. It calls the <code>FLUX.1-kontext-pro</code> model
            via Together AI through Puter's free platform. No API key or signup required &mdash;
            the user's browser makes the AI call directly.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-orange">Orchestration</span>
            <span class="model-card-name">LangGraph (StateGraph)</span>
          </div>
          <p>
            <code>@langchain/langgraph</code> provides the agent orchestration framework.
            A <code>StateGraph</code> defines nodes (router, rag, chart, direct, image, aggregator)
            and conditional edges that route execution based on the router's decision.
            This enables a modular, graph-based workflow.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-green">Context</span>
            <span class="model-card-name">Conversation Memory</span>
          </div>
          <p>
            The agent maintains a rolling history of the last <strong>10 messages</strong> (5 exchanges).
            History is sent with every request and injected into the router prompt, direct answer prompt,
            and RAG prompt &mdash; enabling follow-up questions like "explain that in more detail" or
            "now show that as a pie chart instead." History is managed client-side and capped server-side.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-blue">Rendering</span>
            <span class="model-card-name">Markdown via marked.js</span>
          </div>
          <p>
            LLM responses are rendered as rich HTML using <code>marked.js</code> with GitHub Flavored
            Markdown (GFM). Supports <strong>bold</strong>, <em>italic</em>, headings, bullet/numbered lists,
            inline <code>code</code>, fenced code blocks, blockquotes, tables, and links &mdash; all
            styled with dark-theme typography. Markdown is re-parsed on each streaming token for
            real-time formatted output.
          </p>
        </div>
      </div>

      <!-- Flow Section -->
      <div class="about-section">
        <h3><span class="section-icon">&#128260;</span> How It Works</h3>

        <div class="flow-step">
          <div class="flow-step-num">1</div>
          <div class="flow-step-content">
            <h4>User Sends a Query</h4>
            <p>
              Type a question in the chat input. Optionally attach a PDF (uploaded to Weaviate for RAG)
              or an image (for editing). The query is sent to <code>POST /api/chat/stream</code>.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">2</div>
          <div class="flow-step-content">
            <h4>Intelligent Routing</h4>
            <p>
              The Delegating Agent sends the query to Gemini with a routing prompt, along with
              conversation history for follow-up context. Gemini classifies
              it as one of: <strong>rag</strong> (document search), <strong>chart</strong> (visualization),
              <strong>direct</strong> (general knowledge), <strong>image</strong> (generation/editing),
              or <strong>both</strong> (RAG + chart). If an image is attached, routing is skipped and
              the image route is used automatically.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">3</div>
          <div class="flow-step-content">
            <h4>Tool Execution</h4>
            <p>
              Based on the route, the appropriate tool runs:<br>
              <strong>RAG:</strong> Weaviate semantic search &rarr; Gemini synthesizes answer from retrieved chunks.<br>
              <strong>Chart:</strong> Gemini generates Chart.js config JSON.<br>
              <strong>Direct:</strong> Gemini answers directly from its knowledge.<br>
              <strong>Image (text only):</strong> Pollinations.ai generates an image from the prompt.<br>
              <strong>Image (with photo):</strong> Puter.js edits the photo client-side via FLUX.1 Kontext.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">4</div>
          <div class="flow-step-content">
            <h4>Streaming Response</h4>
            <p>
              The server streams the response token-by-token via SSE (Server-Sent Events).
              The UI renders tokens as they arrive, showing the route badge, answer text,
              references, chart configs, or generated images in real time.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">5</div>
          <div class="flow-step-content">
            <h4>Result Display</h4>
            <p>
              The final response includes the answer text plus any structured data:
              source references (for RAG), chart JSON (for charts), or generated/edited images.
              Response time and the route used are shown at the bottom of each message.
            </p>
          </div>
        </div>
      </div>

      <!-- Tech Stack -->
      <div class="about-section">
        <h3><span class="section-icon">&#128736;</span> Tech Stack</h3>
        <div class="model-card">
          <p>
            <strong>Backend:</strong> Node.js, Express, TypeScript, LangGraph<br>
            <strong>Database:</strong> Weaviate Cloud (vector search)<br>
            <strong>LLM:</strong> Google Gemini 2.5 Flash Lite (free tier)<br>
            <strong>Image Gen:</strong> Pollinations.ai (FLUX), Puter.js (FLUX.1 Kontext Pro)<br>
            <strong>PDF Parsing:</strong> pdf-parse<br>
            <strong>Markdown:</strong> marked.js (GFM)<br>
            <strong>Streaming:</strong> Server-Sent Events (SSE)<br>
            <strong>Deployment:</strong> Koyeb
          </p>
        </div>
      </div>

      <div class="about-footer">
        Built with LangGraph &bull; Weaviate &bull; Gemini &bull; Pollinations.ai &bull; Puter.js &bull; marked.js
      </div>
    </div>
  </div>

  <div class="drag-overlay" id="dragOverlay">Drop PDF or image file here</div>
</body>
</html>