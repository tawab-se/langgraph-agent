<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LangGraph Agent</title>
  <link rel="stylesheet" href="/styles.css">
  <script src="https://js.puter.com/v2/"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
</head>
<body>
  <div class="header">
    <span class="header-icon">&#129302;</span>
    <div>
      <h1>LangGraph Agent</h1>
      <p>Weaviate RAG &bull; Chart.js &bull; Gemini &bull; Pollinations.ai &bull; Puter.js</p>
    </div>
    <button class="about-btn docs-btn" onclick="openDocsPanel()">&#128196; Docs</button>
    <button class="about-btn" onclick="exportChat()" id="exportBtn" style="display:none">&#128190; Export</button>
    <button class="about-btn" onclick="clearChat()">&#10010; New Chat</button>
    <button class="about-btn" onclick="document.getElementById('aboutOverlay').classList.add('active')">&#9432; About</button>
  </div>

  <div class="chat-area" id="chatArea">
    <div class="welcome" id="welcome">
      <h2>What can I help you with?</h2>
      <p>Ask questions about company policies, products, API docs, or request charts.</p>
      <div class="examples">
        <button class="example-btn" onclick="askExample(this)">What is the remote work policy?</button>
        <button class="example-btn" onclick="askExample(this)">Show me a bar chart of sales</button>
        <button class="example-btn" onclick="askExample(this)">What are the ProductX pricing tiers?</button>
        <button class="example-btn" onclick="askExample(this)">What is 25 + 17?</button>
        <button class="example-btn" onclick="askExample(this)">Generate an image of a sunset over mountains</button>
      </div>
    </div>
  </div>

  <div class="input-area">
    <div id="attachmentPreview" class="image-attachment-preview" style="display:none"></div>
    <div class="input-wrapper">
      <input type="file" id="fileInput" accept=".pdf" />
      <input type="file" id="imageInput" accept="image/jpeg,image/png,image/webp" style="display:none" />
      <button class="upload-btn" id="uploadBtn" onclick="document.getElementById('fileInput').click()" title="Upload PDF">
        &#128206; PDF
      </button>
      <button class="upload-btn" id="imageBtn" onclick="document.getElementById('imageInput').click()" title="Attach image for editing">
        &#128247; IMG
      </button>
      <input
        type="text"
        id="queryInput"
        placeholder="Type your question..."
        autocomplete="off"
        autofocus
      />
      <button id="sendBtn" onclick="sendQuery()">Send</button>
    </div>
  </div>

  <script>
    // Configure marked.js with highlight.js for syntax highlighting
    marked.setOptions({
      breaks: true,
      gfm: true,
      highlight: function(code, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try { return hljs.highlight(code, { language: lang }).value; } catch (_) {}
        }
        try { return hljs.highlightAuto(code).value; } catch (_) {}
        return code;
      },
    });

    // Add copy buttons to all <pre> code blocks after markdown render
    function addCodeCopyButtons(container) {
      container.querySelectorAll('pre').forEach(function(pre) {
        if (pre.querySelector('.code-copy-btn')) return;
        var btn = document.createElement('button');
        btn.className = 'code-copy-btn';
        btn.textContent = 'Copy';
        btn.onclick = function() {
          var code = pre.querySelector('code');
          var text = code ? code.textContent : pre.textContent;
          navigator.clipboard.writeText(text).then(function() {
            btn.textContent = 'Copied!';
            setTimeout(function() { btn.textContent = 'Copy'; }, 1500);
          });
        };
        pre.style.position = 'relative';
        pre.appendChild(btn);
      });
    }

    const chatArea = document.getElementById('chatArea');
    const queryInput = document.getElementById('queryInput');
    const sendBtn = document.getElementById('sendBtn');
    const welcome = document.getElementById('welcome');

    // Conversation history (last 10 exchanges sent as context)
    const MAX_HISTORY = 10;
    let conversationHistory = [];

    queryInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !sendBtn.disabled) sendQuery();
    });

    function askExample(btn) {
      queryInput.value = btn.textContent;
      sendQuery();
    }

    function scrollToBottom() {
      chatArea.scrollTop = chatArea.scrollHeight;
    }

    function addUserMessage(text) {
      if (welcome) welcome.remove();
      const div = document.createElement('div');
      div.className = 'message user';
      div.innerHTML = '<div class="bubble">' + escapeHtml(text) + '</div>';
      chatArea.appendChild(div);
      scrollToBottom();
    }

    function addLoadingMessage() {
      const div = document.createElement('div');
      div.className = 'message assistant';
      div.id = 'loading-msg';
      div.innerHTML = '<div class="bubble"><div class="loading-dots"><span></span><span></span><span></span></div></div>';
      chatArea.appendChild(div);
      scrollToBottom();
      return div;
    }

    function removeLoading() {
      const el = document.getElementById('loading-msg');
      if (el) el.remove();
    }

    const ROUTE_MAP = {
      rag: { key: 'rag', label: 'Weaviate RAG', icon: '&#128218;' },
      chart: { key: 'chart', label: 'Chart.js', icon: '&#128202;' },
      direct: { key: 'direct', label: 'Gemini LLM', icon: '&#9889;' },
      both: { key: 'both', label: 'RAG + Chart', icon: '&#9878;' },
      image: { key: 'image', label: 'Pollinations.ai', icon: '&#127912;' },
      'image-edit': { key: 'image', label: 'Puter.js Kontext', icon: '&#127912;' },
    };

    function addErrorMessage(msg, retryQuery, retryImageUrl) {
      const div = document.createElement('div');
      div.className = 'message assistant';
      var html = '<div class="error-msg">' + escapeHtml(msg);
      if (retryQuery) {
        html += '<button class="retry-btn" onclick="retryLastQuery()">&#8635; Retry</button>';
        lastFailedQuery = retryQuery;
        lastFailedImageUrl = retryImageUrl || null;
      }
      html += '</div>';
      div.innerHTML = html;
      chatArea.appendChild(div);
      scrollToBottom();
    }

    var lastFailedQuery = null;
    var lastFailedImageUrl = null;
    function retryLastQuery() {
      if (!lastFailedQuery) return;
      queryInput.value = lastFailedQuery;
      if (lastFailedImageUrl) pendingImageUrl = lastFailedImageUrl;
      lastFailedQuery = null;
      lastFailedImageUrl = null;
      sendQuery();
    }

    function buildReferencesHtml(refs) {
      let html = '<div class="references-section">'
        + '<h4><span class="section-icon">&#128218;</span> Sources from Knowledge Base</h4>';
      refs.forEach(function(ref) {
        const pages = ref.pages.join(', ');
        html += '<span class="ref-item">'
          + '<span class="ref-id">' + escapeHtml(ref.displayId) + '</span>'
          + '<span class="ref-file">' + escapeHtml(ref.fileId) + '</span>'
          + '<span class="ref-pages">Pages ' + escapeHtml(pages) + '</span>'
          + '</span>';
      });
      html += '</div>';
      return html;
    }

    function buildChartHtml(cfg, canvasId) {
      const json = JSON.stringify(cfg, null, 2);
      const jsonBlockId = canvasId + '-json';
      let html = '<div class="chart-section">'
        + '<h4><span class="section-icon">&#128202;</span> Chart</h4>'
        + '<div class="chart-meta">'
        + '<div class="chart-meta-item">Type: <span class="val">' + escapeHtml(cfg.type) + '</span></div>'
        + '<div class="chart-meta-item">Labels: <span class="val">' + cfg.data.labels.length + '</span></div>'
        + '<div class="chart-meta-item">Datasets: <span class="val">' + cfg.data.datasets.length + '</span></div>'
        + '</div>'
        + '<div class="chart-canvas-wrapper"><canvas id="' + canvasId + '"></canvas></div>'
        + '<button class="chart-json-toggle" onclick="toggleChartJson(\'' + jsonBlockId + '\', this)">&#9660; Show JSON</button>'
        + '<div id="' + jsonBlockId + '" class="chart-block" style="display:none">'
        + '<div class="chart-block-header">'
        + '<span>chart.js config</span>'
        + '<button class="copy-btn" onclick="copyToClipboard(this)">Copy JSON</button>'
        + '</div>'
        + '<pre>' + escapeHtml(json) + '</pre>'
        + '</div></div>';
      return html;
    }

    function toggleChartJson(blockId, btn) {
      var block = document.getElementById(blockId);
      if (!block) return;
      if (block.style.display === 'none') {
        block.style.display = 'block';
        btn.innerHTML = '&#9650; Hide JSON';
      } else {
        block.style.display = 'none';
        btn.innerHTML = '&#9660; Show JSON';
      }
    }

    function renderChart(canvasId, cfg) {
      var canvas = document.getElementById(canvasId);
      if (!canvas || typeof Chart === 'undefined') return;
      try {
        // Deep clone to avoid mutating original config
        var config = JSON.parse(JSON.stringify(cfg));
        // Ensure responsive behavior
        if (!config.options) config.options = {};
        config.options.responsive = true;
        config.options.maintainAspectRatio = true;
        // Dark theme defaults
        if (!config.options.plugins) config.options.plugins = {};
        if (!config.options.plugins.legend) config.options.plugins.legend = {};
        if (!config.options.plugins.legend.labels) config.options.plugins.legend.labels = {};
        config.options.plugins.legend.labels.color = '#c9d1d9';
        // Only apply axis styles for chart types that use scales (not pie/doughnut/radar/polarArea)
        var noScaleTypes = ['pie', 'doughnut', 'radar', 'polarArea'];
        if (noScaleTypes.indexOf(config.type) === -1) {
          if (!config.options.scales) config.options.scales = {};
          ['x', 'y'].forEach(function(axis) {
            if (!config.options.scales[axis]) config.options.scales[axis] = {};
            if (!config.options.scales[axis].ticks) config.options.scales[axis].ticks = {};
            config.options.scales[axis].ticks.color = '#8b949e';
            if (!config.options.scales[axis].grid) config.options.scales[axis].grid = {};
            config.options.scales[axis].grid.color = '#21262d';
          });
        }
        new Chart(canvas.getContext('2d'), config);
      } catch (err) {
        console.error('Chart render error:', err);
        canvas.parentElement.innerHTML = '<div style="color:#f85149;font-size:12px;padding:12px">Failed to render chart. JSON config is available below.</div>';
      }
    }

    function buildImageHtml(data, imgId) {
      return '<div class="image-section">'
        + '<h4>&#127912; Generated Image</h4>'
        + '<div id="' + imgId + '-loader" class="image-loading">'
        + '<div class="spinner"></div><div>Generating image... this may take 10-30 seconds</div></div>'
        + '<img id="' + imgId + '" style="display:none" alt="' + escapeHtml(data.prompt) + '" />'
        + '<div class="image-caption">' + escapeHtml(data.prompt) + ' (model: ' + escapeHtml(data.model) + ')</div>'
        + '</div>';
    }

    // Preload image with retry â€” called after buildImageHtml is inserted into DOM
    function loadGeneratedImage(url, imgId, retries) {
      if (retries === undefined) retries = 3;
      var img = new Image();
      img.onload = function() {
        var el = document.getElementById(imgId);
        var loader = document.getElementById(imgId + '-loader');
        if (el) { el.src = url; el.style.display = 'block'; }
        if (loader) loader.remove();
        scrollToBottom();
      };
      img.onerror = function() {
        if (retries > 0) {
          setTimeout(function() { loadGeneratedImage(url, imgId, retries - 1); }, 5000);
        } else {
          var loader = document.getElementById(imgId + '-loader');
          if (loader) loader.innerHTML = 'Image generation failed. <a href="' + url + '" target="_blank" style="color:#58a6ff">Open directly</a>';
        }
      };
      img.src = url;
    }

    function buildImageEditHtml(imgId) {
      return '<div class="image-section">'
        + '<h4>&#127912; Edited Image</h4>'
        + '<div id="' + imgId + '-loader" class="image-loading">'
        + '<div class="spinner"></div><div>Editing image via Puter.js... this may take 10-30 seconds</div></div>'
        + '<img id="' + imgId + '" style="display:none" />'
        + '</div>';
    }

    function runPuterImageEdit(prompt, imageUrl, imgId) {
      // Convert relative URL to absolute for Puter.js
      var absUrl = imageUrl.startsWith('http') ? imageUrl : window.location.origin + imageUrl;

      puter.ai.txt2img(prompt, {
        model: 'togetherai:black-forest-labs/flux.1-kontext-pro',
        image_url: absUrl
      }).then(function(imgEl) {
        var el = document.getElementById(imgId);
        var loader = document.getElementById(imgId + '-loader');
        if (el) {
          el.src = imgEl.src;
          el.style.display = 'block';
        }
        if (loader) loader.remove();
        scrollToBottom();
      }).catch(function(err) {
        var loader = document.getElementById(imgId + '-loader');
        if (loader) loader.innerHTML = 'Image editing failed: ' + escapeHtml(String(err.message || err));
      });
    }

    // --- Image Attachment State ---
    let pendingImageUrl = null;
    const attachmentPreview = document.getElementById('attachmentPreview');
    const imageInput = document.getElementById('imageInput');
    const imageBtn = document.getElementById('imageBtn');

    imageInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      imageInput.value = '';
      await attachImage(file);
    });

    async function attachImage(file) {
      if (!file.type.startsWith('image/')) {
        showToast('Only image files (JPEG, PNG, WebP) are supported', 'error');
        return;
      }
      if (file.size > 10 * 1024 * 1024) {
        showToast('Image too large. Maximum size is 10 MB.', 'error');
        return;
      }

      imageBtn.disabled = true;
      showToast('Uploading image...', 'uploading', 0);

      const formData = new FormData();
      formData.append('image', file);

      try {
        const res = await fetch('/api/upload/image', { method: 'POST', body: formData });
        dismissToast();
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || err.error || 'Upload failed');
        }
        const result = await res.json();
        pendingImageUrl = result.url;

        // Show preview
        attachmentPreview.style.display = 'flex';
        attachmentPreview.innerHTML = '<img src="' + escapeHtml(result.url) + '" />'
          + '<span class="attachment-name">' + escapeHtml(file.name) + ' attached</span>'
          + '<button class="remove-attachment" onclick="clearAttachment()" title="Remove">&#10005;</button>';
        queryInput.placeholder = 'Describe what to do with this image...';
        queryInput.focus();
      } catch (err) {
        dismissToast();
        showToast('Image upload failed: ' + err.message, 'error', 5000);
      } finally {
        imageBtn.disabled = false;
      }
    }

    function clearAttachment() {
      pendingImageUrl = null;
      attachmentPreview.style.display = 'none';
      attachmentPreview.innerHTML = '';
      queryInput.placeholder = 'Type your question...';
    }

    async function sendQuery() {
      const query = queryInput.value.trim();
      if (!query) return;

      const imageUrl = pendingImageUrl;
      clearAttachment();

      queryInput.value = '';
      sendBtn.disabled = true;
      queryInput.disabled = true;

      addUserMessage(imageUrl ? query + ' [image attached]' : query);
      addLoadingMessage();

      const startTime = Date.now();
      const STREAM_TIMEOUT = 60000;
      const controller = new AbortController();
      const timeoutId = setTimeout(function() { controller.abort(); }, STREAM_TIMEOUT);

      try {
        const res = await fetch('/api/chat/stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query, imageUrl, history: conversationHistory }),
          signal: controller.signal,
        });

        if (!res.ok) {
          removeLoading();
          const err = await res.json().catch(function() { return {}; });
          throw new Error(err.message || err.error || 'Request failed');
        }

        removeLoading();

        // Create streaming message container
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message assistant';
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        msgDiv.appendChild(bubble);

        // Route badge placeholder
        const badgeEl = document.createElement('div');
        badgeEl.className = 'route-badge route-direct';
        badgeEl.innerHTML = '<span class="route-dot"></span>Thinking...';
        bubble.appendChild(badgeEl);

        // Answer text element
        const answerEl = document.createElement('div');
        answerEl.className = 'answer-text';
        bubble.appendChild(answerEl);

        chatArea.appendChild(msgDiv);
        scrollToBottom();

        let answerText = '';
        let route = ROUTE_MAP.direct;
        let allData = [];

        // Parse SSE stream
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          let eventType = '';
          for (const line of lines) {
            if (line.startsWith('event: ')) {
              eventType = line.slice(7).trim();
            } else if (line.startsWith('data: ') && eventType) {
              const data = JSON.parse(line.slice(6));

              if (eventType === 'thinking') {
                badgeEl.innerHTML = '<span class="route-dot"></span>' + data;
              } else if (eventType === 'route') {
                const tool = data.tools ? data.tools[0] : 'direct';
                route = ROUTE_MAP[tool] || ROUTE_MAP.direct;
                badgeEl.className = 'route-badge route-' + route.key;
                badgeEl.innerHTML = '<span class="route-dot"></span>Answered via ' + route.label;
              } else if (eventType === 'token') {
                answerText += data;
                answerEl.innerHTML = marked.parse(answerText);
                addCodeCopyButtons(answerEl);
                scrollToBottom();
              } else if (eventType === 'sources') {
                answerText += '\n\nSources: ' + data;
                answerEl.innerHTML = marked.parse(answerText);
                addCodeCopyButtons(answerEl);
              } else if (eventType === 'references') {
                bubble.insertAdjacentHTML('beforeend', buildReferencesHtml(data));
                allData = allData.concat(data);
              } else if (eventType === 'chart') {
                var chartCanvasId = 'chart-' + Date.now();
                bubble.insertAdjacentHTML('beforeend', buildChartHtml(data, chartCanvasId));
                renderChart(chartCanvasId, data);
                allData.push({ type: 'chart', config: data });
              } else if (eventType === 'image') {
                var imgId = 'gen-img-' + Date.now();
                bubble.insertAdjacentHTML('beforeend', buildImageHtml(data, imgId));
                loadGeneratedImage(data.url, imgId);
                allData.push({ type: 'image', url: data.url, prompt: data.prompt });
              } else if (eventType === 'image-edit') {
                var editImgId = 'edit-img-' + Date.now();
                route = ROUTE_MAP['image-edit'];
                badgeEl.className = 'route-badge route-image';
                badgeEl.innerHTML = '<span class="route-dot"></span>Answered via ' + route.label;
                bubble.insertAdjacentHTML('beforeend', buildImageEditHtml(editImgId));
                runPuterImageEdit(data.prompt, data.imageUrl, editImgId);
                scrollToBottom();
              } else if (eventType === 'done') {
                if (Array.isArray(data) && data.length > 0) allData = data;
              } else if (eventType === 'error') {
                answerEl.textContent = 'Error: ' + data;
              }

              eventType = '';
            }
          }
        }

        // Add response time
        const elapsed = Date.now() - startTime;
        const timeStr = elapsed < 1000 ? elapsed + 'ms' : (elapsed / 1000).toFixed(1) + 's';
        const metaDiv = document.createElement('div');
        metaDiv.className = 'response-meta';
        metaDiv.innerHTML = '<span>' + route.icon + ' ' + route.label + '</span>'
          + '<span>&#8226;</span>'
          + '<span>' + timeStr + '</span>';
        bubble.appendChild(metaDiv);
        scrollToBottom();

        clearTimeout(timeoutId);

        // Save to conversation history for follow-up context
        conversationHistory.push({ role: 'user', content: query });
        if (answerText.trim()) {
          conversationHistory.push({ role: 'assistant', content: answerText.trim() });
        }
        // Keep only the last MAX_HISTORY messages
        if (conversationHistory.length > MAX_HISTORY) {
          conversationHistory = conversationHistory.slice(-MAX_HISTORY);
        }

        // Show export button now that we have chat content
        document.getElementById('exportBtn').style.display = '';

      } catch (err) {
        clearTimeout(timeoutId);
        removeLoading();
        var errMsg = err.name === 'AbortError'
          ? 'Error: Request timed out after 60 seconds. The server may be overloaded.'
          : 'Error: ' + err.message;
        addErrorMessage(errMsg, query, imageUrl);
      } finally {
        sendBtn.disabled = false;
        queryInput.disabled = false;
        queryInput.focus();
      }
    }

    function copyToClipboard(btn) {
      const pre = btn.closest('.chart-block').querySelector('pre');
      navigator.clipboard.writeText(pre.textContent).then(() => {
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy JSON'; }, 1500);
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.appendChild(document.createTextNode(text));
      return div.innerHTML;
    }

    // --- File Upload ---
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    let isUploading = false;

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) uploadFile(file);
      fileInput.value = '';
    });

    async function uploadFile(file) {
      if (isUploading) return;
      if (file.type !== 'application/pdf') {
        showToast('Only PDF files are supported', 'error');
        return;
      }
      if (file.size > 20 * 1024 * 1024) {
        showToast('File too large. Maximum size is 20 MB.', 'error');
        return;
      }

      isUploading = true;
      uploadBtn.disabled = true;
      showToast('Uploading "' + file.name + '"...', 'uploading', 0);

      const formData = new FormData();
      formData.append('pdf', file);

      try {
        const res = await fetch('/api/upload', {
          method: 'POST',
          body: formData,
        });

        dismissToast();

        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.message || err.error || 'Upload failed');
        }

        const result = await res.json();
        showToast(result.message, 'success', 5000);
        addSystemMessage('Uploaded "' + result.filename + '" \u2014 ' + result.totalPages + ' pages, ' + result.chunksCreated + ' chunks indexed. You can now ask questions about this document.');
      } catch (err) {
        dismissToast();
        showToast('Upload failed: ' + err.message, 'error', 5000);
      } finally {
        isUploading = false;
        uploadBtn.disabled = false;
      }
    }

    function showToast(message, type, duration) {
      if (duration === undefined) duration = 4000;
      dismissToast();
      const toast = document.createElement('div');
      toast.className = 'upload-toast ' + type;
      toast.id = 'currentToast';
      toast.textContent = message;
      document.body.appendChild(toast);
      if (duration > 0) {
        setTimeout(dismissToast, duration);
      }
    }

    function dismissToast() {
      const el = document.getElementById('currentToast');
      if (el) el.remove();
    }

    function addSystemMessage(text) {
      if (welcome) welcome.remove();
      const div = document.createElement('div');
      div.className = 'message assistant';
      div.innerHTML = '<div class="bubble">'
        + '<div class="route-badge route-direct"><span class="route-dot"></span>System</div>'
        + '<div class="answer-text">' + escapeHtml(text) + '</div>'
        + '</div>';
      chatArea.appendChild(div);
      scrollToBottom();
    }

    // Drag and drop
    const dragOverlay = document.getElementById('dragOverlay');
    let dragCounter = 0;

    document.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      if (e.dataTransfer.types.includes('Files')) {
        dragOverlay.classList.add('active');
      }
    });

    document.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        dragOverlay.classList.remove('active');
      }
    });

    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dragOverlay.classList.remove('active');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.type === 'application/pdf') {
          uploadFile(file);
        } else if (file.type.startsWith('image/')) {
          attachImage(file);
        } else {
          showToast('Only PDF and image files are supported', 'error');
        }
      }
    });

    // --- Document Management ---
    async function openDocsPanel() {
      document.getElementById('docsOverlay').classList.add('active');
      await loadDocuments();
    }

    function closeDocsPanel() {
      document.getElementById('docsOverlay').classList.remove('active');
    }

    async function loadDocuments() {
      var content = document.getElementById('docsContent');
      var summary = document.getElementById('docsSummary');

      content.innerHTML = '<div class="docs-loading">'
        + '<div class="loading-dots"><span></span><span></span><span></span></div>'
        + '<p>Loading documents...</p></div>';
      summary.textContent = '';

      try {
        var res = await fetch('/api/documents');
        if (!res.ok) throw new Error('Failed to fetch documents');
        var result = await res.json();
        var docs = result.data;

        if (!docs || docs.length === 0) {
          content.innerHTML = '<div class="docs-empty">'
            + '<p>No documents indexed yet.</p>'
            + '<p>Upload a PDF using the <strong>&#128206; PDF</strong> button to get started.</p>'
            + '</div>';
          summary.textContent = '0 documents';
          return;
        }

        var totalChunks = 0;
        var html = '';

        docs.forEach(function(doc) {
          totalChunks += doc.chunkCount;
          var pages = doc.pages.join(', ');
          var pageLabel = doc.pages.length === 1 ? '1 page' : doc.pages.length + ' pages';

          html += '<div class="doc-card" id="doc-' + encodeURIComponent(doc.fileId) + '">'
            + '<div class="doc-card-header">'
            + '<div class="doc-card-info">'
            + '<span class="doc-card-name">&#128196; ' + escapeHtml(doc.fileId) + '</span>'
            + '<div class="doc-card-meta">'
            + '<span class="doc-meta-item">' + doc.chunkCount + ' chunks</span>'
            + '<span class="doc-meta-sep">&#8226;</span>'
            + '<span class="doc-meta-item">' + pageLabel + '</span>'
            + '</div>'
            + '</div>'
            + '<button class="doc-delete-btn" onclick="deleteDoc(\'' + escapeHtml(doc.fileId).replace(/'/g, "\\'") + '\')" title="Delete document">&#128465;</button>'
            + '</div>'
            + '<div class="doc-card-pages">'
            + '<span class="doc-pages-label">Pages:</span> '
            + '<span class="doc-pages-list">' + escapeHtml(pages) + '</span>'
            + '</div>'
            + '</div>';
        });

        content.innerHTML = html;
        summary.textContent = docs.length + ' document' + (docs.length !== 1 ? 's' : '') + ' \u2022 ' + totalChunks + ' total chunks';
      } catch (err) {
        content.innerHTML = '<div class="docs-error">'
          + '<p>Failed to load documents: ' + escapeHtml(err.message) + '</p>'
          + '</div>';
      }
    }

    async function deleteDoc(fileId) {
      if (!confirm('Delete "' + fileId + '" and all its chunks from Weaviate?\n\nThis cannot be undone.')) {
        return;
      }

      var card = document.getElementById('doc-' + encodeURIComponent(fileId));
      if (card) {
        card.style.opacity = '0.5';
        card.style.pointerEvents = 'none';
      }

      try {
        var res = await fetch('/api/documents/' + encodeURIComponent(fileId), {
          method: 'DELETE',
        });

        if (!res.ok) {
          var err = await res.json().catch(function() { return {}; });
          throw new Error(err.message || err.error || 'Delete failed');
        }

        var result = await res.json();
        showToast(result.message, 'success', 4000);
        await loadDocuments();
      } catch (err) {
        showToast('Delete failed: ' + err.message, 'error', 5000);
        if (card) {
          card.style.opacity = '1';
          card.style.pointerEvents = 'auto';
        }
      }
    }

    // --- New Chat ---
    function clearChat() {
      var messages = chatArea.querySelectorAll('.message');
      if (messages.length === 0) return;
      if (!confirm('Clear conversation and start fresh?')) return;
      chatArea.innerHTML = '';
      conversationHistory = [];
      document.getElementById('exportBtn').style.display = 'none';
      // Re-add welcome
      var w = document.createElement('div');
      w.className = 'welcome';
      w.id = 'welcome';
      w.innerHTML = '<h2>What can I help you with?</h2>'
        + '<p>Ask questions about company policies, products, API docs, or request charts.</p>'
        + '<div class="examples">'
        + '<button class="example-btn" onclick="askExample(this)">What is the remote work policy?</button>'
        + '<button class="example-btn" onclick="askExample(this)">Show me a bar chart of sales</button>'
        + '<button class="example-btn" onclick="askExample(this)">What are the ProductX pricing tiers?</button>'
        + '<button class="example-btn" onclick="askExample(this)">What is 25 + 17?</button>'
        + '<button class="example-btn" onclick="askExample(this)">Generate an image of a sunset over mountains</button>'
        + '</div>';
      chatArea.appendChild(w);
    }

    // --- Chat Export ---
    function exportChat() {
      var md = '# LangGraph Agent Chat Export\n';
      md += '_Exported: ' + new Date().toLocaleString() + '_\n\n---\n\n';
      conversationHistory.forEach(function(msg) {
        if (msg.role === 'user') {
          md += '**You:** ' + msg.content + '\n\n';
        } else {
          md += '**Assistant:** ' + msg.content + '\n\n---\n\n';
        }
      });
      var blob = new Blob([md], { type: 'text/markdown' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'chat-export-' + new Date().toISOString().slice(0, 10) + '.md';
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>

  <!-- Documents Modal -->
  <div class="about-overlay" id="docsOverlay" onclick="if(event.target===this)closeDocsPanel()">
    <div class="about-modal docs-modal">
      <button class="about-close" onclick="closeDocsPanel()">&times;</button>
      <h2>&#128196; Indexed Documents</h2>
      <p class="about-subtitle">PDFs currently stored in Weaviate. Each document is split into chunks for semantic search.</p>
      <div id="docsContent">
        <div class="docs-loading">
          <div class="loading-dots"><span></span><span></span><span></span></div>
          <p>Loading documents...</p>
        </div>
      </div>
      <div class="about-footer">
        <span id="docsSummary"></span>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div class="about-overlay" id="aboutOverlay" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="about-modal">
      <button class="about-close" onclick="document.getElementById('aboutOverlay').classList.remove('active')">&times;</button>

      <h2>LangGraph Agent</h2>
      <p class="about-subtitle">
        A multi-route AI agent built with LangGraph, Node.js, and Express. The agent intelligently routes each query
        to the right tool &mdash; RAG search, chart generation, direct LLM answer, text-to-image, or image editing &mdash;
        and streams the response in real time via Server-Sent Events (SSE).
      </p>

      <!-- Models Section -->
      <div class="about-section">
        <h3><span class="section-icon">&#129520;</span> Models &amp; Services</h3>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-green">Router + Direct + RAG</span>
            <span class="model-card-name">Gemini 2.5 Flash Lite</span>
          </div>
          <p>
            Google's <code>gemini-2.5-flash-lite</code> model powers three core functions:
            <strong>query routing</strong> (deciding which tool handles each query),
            <strong>direct answers</strong> (general knowledge, coding, math), and
            <strong>RAG synthesis</strong> (generating answers from retrieved document chunks).
            Free tier: 1,000 requests/day, 15 requests/minute. Rate-limit errors (429)
            are automatically retried with exponential backoff (up to 3 retries). If the
            daily quota is exhausted, a user-friendly message is shown instead.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-blue">Vector Database</span>
            <span class="model-card-name">Weaviate Cloud</span>
          </div>
          <p>
            Weaviate is used as the vector database for RAG (Retrieval-Augmented Generation).
            When you upload a PDF, it is parsed into text chunks and stored as vector embeddings
            in Weaviate. When a document-related query is routed to RAG, Weaviate performs a
            semantic similarity search to find the most relevant chunks.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-purple">Chart Generation</span>
            <span class="model-card-name">Chart.js via Gemini</span>
          </div>
          <p>
            When a chart or visualization is requested, Gemini generates a valid
            <code>Chart.js</code> JSON configuration (type, labels, datasets, colors).
            The chart is rendered visually inline in the chat using the Chart.js library,
            with dark-theme styling applied automatically. The raw JSON config can also
            be expanded and copied via the "Show JSON" toggle below each chart.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-pink">Text-to-Image</span>
            <span class="model-card-name">Pollinations.ai &mdash; FLUX</span>
          </div>
          <p>
            Text-to-image generation uses <code>Pollinations.ai</code> with the <code>flux</code> model.
            The server constructs a Pollinations image URL with the user's prompt, and the browser
            loads it via <code>&lt;img src&gt;</code>. The image is generated on the first GET request.
            Requires a free publishable API key (<code>pk_</code>).
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-pink">Image Editing</span>
            <span class="model-card-name">Puter.js &mdash; FLUX.1 Kontext Pro</span>
          </div>
          <p>
            Image editing (upload a photo + describe edits) uses <code>Puter.js</code> running
            client-side in the browser. It calls the <code>FLUX.1-kontext-pro</code> model
            via Together AI through Puter's free platform. No API key or signup required &mdash;
            the user's browser makes the AI call directly.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-orange">Orchestration</span>
            <span class="model-card-name">LangGraph (StateGraph)</span>
          </div>
          <p>
            <code>@langchain/langgraph</code> provides the agent orchestration framework.
            A <code>StateGraph</code> defines nodes (router, rag, chart, direct, image, aggregator)
            and conditional edges that route execution based on the router's decision.
            This enables a modular, graph-based workflow.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-green">Context</span>
            <span class="model-card-name">Conversation Memory</span>
          </div>
          <p>
            The agent maintains a rolling history of the last <strong>10 messages</strong> (5 exchanges).
            History is sent with every request and injected into the router prompt, direct answer prompt,
            and RAG prompt &mdash; enabling follow-up questions like "explain that in more detail" or
            "now show that as a pie chart instead." History is managed client-side and capped server-side.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-blue">Rendering</span>
            <span class="model-card-name">Markdown via marked.js</span>
          </div>
          <p>
            LLM responses are rendered as rich HTML using <code>marked.js</code> with GitHub Flavored
            Markdown (GFM). Supports <strong>bold</strong>, <em>italic</em>, headings, bullet/numbered lists,
            inline <code>code</code>, fenced code blocks, blockquotes, tables, and links &mdash; all
            styled with dark-theme typography. Code blocks get <code>highlight.js</code> syntax coloring
            and a one-click copy button. Markdown is re-parsed on each streaming token for
            real-time formatted output.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-orange">Management</span>
            <span class="model-card-name">Document Panel</span>
          </div>
          <p>
            The <strong>Docs</strong> button in the header opens a document management panel showing all
            PDFs currently indexed in Weaviate. Each entry displays the filename, chunk count, and page
            numbers. Documents can be deleted individually, removing all associated chunks from the
            vector database.
          </p>
        </div>

        <div class="model-card">
          <div class="model-card-header">
            <span class="model-card-badge badge-purple">UX</span>
            <span class="model-card-name">Chat Controls</span>
          </div>
          <p>
            <strong>New Chat</strong> clears the conversation and resets history.
            <strong>Export</strong> downloads the full chat as a Markdown file.
            Failed requests show a <strong>Retry</strong> button to resend the query.
            Streaming requests have a 60-second timeout to prevent indefinite hangs.
          </p>
        </div>
      </div>

      <!-- Flow Section -->
      <div class="about-section">
        <h3><span class="section-icon">&#128260;</span> How It Works</h3>

        <div class="flow-step">
          <div class="flow-step-num">1</div>
          <div class="flow-step-content">
            <h4>User Sends a Query</h4>
            <p>
              Type a question in the chat input. Optionally attach a PDF (uploaded to Weaviate for RAG)
              or an image (for editing). The query is sent to <code>POST /api/chat/stream</code>.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">2</div>
          <div class="flow-step-content">
            <h4>Intelligent Routing</h4>
            <p>
              The Delegating Agent sends the query to Gemini with a routing prompt, along with
              conversation history for follow-up context. Gemini classifies
              it as one of: <strong>rag</strong> (document search), <strong>chart</strong> (visualization),
              <strong>direct</strong> (general knowledge), <strong>image</strong> (generation/editing),
              or <strong>both</strong> (RAG + chart). If an image is attached, routing is skipped and
              the image route is used automatically.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">3</div>
          <div class="flow-step-content">
            <h4>Tool Execution</h4>
            <p>
              Based on the route, the appropriate tool runs:<br>
              <strong>RAG:</strong> Weaviate semantic search &rarr; Gemini synthesizes answer from retrieved chunks.<br>
              <strong>Chart:</strong> Gemini generates Chart.js config JSON.<br>
              <strong>Direct:</strong> Gemini answers directly from its knowledge.<br>
              <strong>Image (text only):</strong> Pollinations.ai generates an image from the prompt.<br>
              <strong>Image (with photo):</strong> Puter.js edits the photo client-side via FLUX.1 Kontext.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">4</div>
          <div class="flow-step-content">
            <h4>Streaming Response</h4>
            <p>
              The server streams the response token-by-token via SSE (Server-Sent Events).
              The UI renders tokens as they arrive, showing the route badge, answer text,
              references, chart configs, or generated images in real time.
            </p>
          </div>
        </div>

        <div class="flow-step">
          <div class="flow-step-num">5</div>
          <div class="flow-step-content">
            <h4>Result Display</h4>
            <p>
              The final response includes the answer text plus any structured data:
              source references (for RAG), chart JSON (for charts), or generated/edited images.
              Response time and the route used are shown at the bottom of each message.
            </p>
          </div>
        </div>
      </div>

      <!-- Tech Stack -->
      <div class="about-section">
        <h3><span class="section-icon">&#128736;</span> Tech Stack</h3>
        <div class="model-card">
          <p>
            <strong>Backend:</strong> Node.js, Express, TypeScript, LangGraph<br>
            <strong>Database:</strong> Weaviate Cloud (vector search)<br>
            <strong>LLM:</strong> Google Gemini 2.5 Flash Lite (free tier)<br>
            <strong>Image Gen:</strong> Pollinations.ai (FLUX), Puter.js (FLUX.1 Kontext Pro)<br>
            <strong>PDF Parsing:</strong> pdf-parse<br>
            <strong>Markdown:</strong> marked.js (GFM) + highlight.js<br>
            <strong>Streaming:</strong> Server-Sent Events (SSE)<br>
            <strong>Deployment:</strong> Koyeb
          </p>
        </div>
      </div>

      <div class="about-footer">
        Built with LangGraph &bull; Weaviate &bull; Gemini &bull; Pollinations.ai &bull; Puter.js &bull; marked.js
      </div>
    </div>
  </div>

  <div class="drag-overlay" id="dragOverlay">Drop PDF or image file here</div>
</body>
</html>